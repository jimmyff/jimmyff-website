+++
title = "Beyond package management: How Nix refactored my digital life"
date = 2025-09-08
[taxonomies]
tags = ["coding", "nix"]
+++

_(You can find my Nix config [over on Github](https://github.com/jimmyff/nixfiles/))_

I'm a disorganised person. My workflow is to bounce around a codebase for days/weeks at a time and when I come up for air I'll usually have left a slew of configs, tools, scripts, repos scattered around my computer like the socks near the bed, or the pile of paperwork on my desk. After a while I reach a point where it all becomes unmanageable. I'll wade on (unproductively) until I can't go any further, then reset my laptop and spend a week reconfiguring the system, tooling, and getting projects running again. So when I discovered Nix (about 12 months back) it sounded _too_ good to be true: a declarative package manager with reproducible builds and pinned package versions. Even better, NixOS applies these principles to your entire operating system! I was incredibly excited by it but then got horrendously bogged down in my first system config. I shelved it as something to come back to when I had more time. Several months later I gave it another try and spent the time needed to understand how to properly configure it. Result? Well let's just say I'm never going back -boy oh boy, Nix is *wild*! In this post, I'll walk you through my journey: reviving an old Pixelbook with [NixOS](https://nixos.org/), wrangling my MacBook with [nix-darwin](https://github.com/nix-darwin/nix-darwin), and super-charging Nix with AI to solve a problem I thought was unsolvable.

### NixOS on an old Pixelbook

I gave Nix a second chance as I had a slow old Pixelbook Go (2017 Chromebook that I'd picked-up cheap on ebay). It frustrated me how sluggish it was despite being reasonably well-specced. I disabled the BIOS write protection (using the excellent guides at [MrChromebox](https://docs.mrchromebox.tech/)) and replaced it with Coreboot, an open-source BIOS that allowed me to install NixOS (_the process was more involved than expected, requiring me to physically disconnect the battery to disable write protection!_). Getting a simple NixOS system running was simple and I was instantly blown away by the speed! The Pixelbook (_now a Nixelbook_) had *never* felt so snappy -it was a joy to use. I've not used Linux on the desktop for almost 15 years (I started on Linux in the early 2000s with Debian Woody and remember the hype around Ubuntu Warty Warthog!) so I had great fun playing around with all the cool new stuff -especially the display managers! Everything worked remarkably well except the parts specific to the Pixelbook: The AI assistant button, the function key row and the speakers. _I've almost got everything working now -more on this later!_

{{ image(src="nixelbook.webp", alt="Left: Disconnecting the battery of my Pixelbook. Right: My Nixelbook is born!") }}

### Running Nix on my macbook

The Nixelbook was a triumph, but could I apply this same magic to my daily driver, a chaotic M1 MacBook Pro? My system is a mess; way too much stuff, brew packages, countless dev projects, tooling and SDKs installed globally. I'm also never quite sure about the correct way to fully purge something on macOS (especially if it's been installed via an installer). Enter Nix: I can now enable those configurations I setup for my NixOS laptop on a per-module basis for my macbook. The macOS version of Nix configuration is handled by [nix-darwin](https://github.com/nix-darwin/nix-darwin), which has some differences and gotchas due to macOS's BSD Unix foundation versus Linux. Also I'm running an Apple silicon macbook pro- so the packages I use need to have aarch64-darwin builds (which most do). With a little bit of patience you can configure your various hosts and share your nix modules across systems with different architectures. This for me is huge: I can have a dependable, reproducible configuration, I am in control of every aspect, and every configuration is deliberate, considered and under version control. 


### Declarative Dev Environments

I've previously used Ansible for dev-ops configuration, it's powerful but also painful. I found that it would be overkill for my smaller projects, and it certainly wouldn't be good for configuring desktop tooling etc. The NixOS package repository with pinned versions is the HUGE differentiator for me. I'm not at the stage of configuring cloud containers with NixOS (that will be a challenge for another day), but for local development environments this is massive. For this, I use [Nix Flakes](https://nixos.wiki/wiki/Flakes). Flakes are the modern way to package Nix expressions, locking all dependencies for true reproducibility. I configure my projects as Nix Flakes that checkout the code, provide utility scripts and configure the environment by installing SDKs (pinned to specific version) and any tooling required. With direnv, the entire environment appears when entering a project directory and disappears when leaving: SDKs, running services, tooling, even IDEs if desired. Doing something like this, supporting different system architectures with Ansible would be a nightmare (and far beyond my ability!). As I can now reproduce my configurations I'm leaning heavily in to nushell as my default shell environment, and I've created a couple of nuscripts ([gm.nu](https://github.com/jimmyff/nixfiles/tree/main/scripts/git-manager) and [dartboard.nu](https://github.com/jimmyff/nixfiles/tree/main/scripts/dartboard)) to manage my bigger projects, handling everything from batch-updating and running tests across various projects to syncing and managing git submodules in mono-repos. My flakes ([example](https://github.com/jimmyff/nixfiles/blob/main/projects/rocket-kit/flake.nix)) can enable these global scripts, and I have them configured to give me a project overview each time the flake is loaded. I'm willing to spend longer creating the perfect dev environment as now it's reproducible, my utility tools and scripts can be shared among projects and I'm seeing qualitative improvements to my developer experience because of it.

### Nix + AI = ðŸ¤¯

My biggest challenge was the Nixelbook's audio. After replacing the firmware, I discovered the audio drivers were unavailable -a dead end that others online had hit with no success. I'd failed miserably trying to fix it myself. As a last resort, I decided to see if an AI could help me crack it. I tasked Claude Code with the problem and the results were astonishingâ€”I watched as the AI assistant (under close supervision) methodically tried various approaches while monitoring system logs and working through errors I probably would never have discovered. Eventually it(/we?) managed to locate the final piece of the puzzle: the speakers topology file (that someone had recovered from the ChromeOS recovery image) which with some impressive nix configuration literally brought music to my ears _(if you have a Pixelbook Go/Chromebook Atlas, [help yourself to the solution here](https://github.com/jimmyff/nixfiles/tree/main/nix_modules/hardware/pixelbook-go)!)._


### What's next & final thoughts

Earlier this year [Google released 'Linux Terminal' which provides a virtualized Linux environment on Android](https://www.androidauthority.com/android-linux-terminal-app-available-3532999/), of course [there is already Nix support](https://github.com/nix-community/nix-on-droid). I'm going to configure my Pixel phone as a host in my nix config which will give me a fully-fledged, perfectly configured Linux OS in my pocket- everything setup just the way I like it. I could also play with using Nix as a tool for configuring cloud infrastructure -something I would like to explore further down the road.

My closing comment is that Nix has blown me away. It's refactored my chaotic digital life in to something well structured, thoughtfully considered, reproducible and dependable, and I'm reaping the rewards of all of this already. I urge everyone to take a look at Nix and give it the time it deserves; you can thank me later (_over in my [guestbook](/guestbook/)!_).

---

_[github.com/jimmyff/nixfiles/](https://github.com/jimmyff/nixfiles/)_
